import java.util.Enumeration;
import java.util.LinkedList;

/* Generated by Together */

/**
 * Permit list manages the collection of permits currently issued and not yet cancelled (or expired).
 * It handles most of the use cases in the Administration section. Note that each Permit must have a
 * unique permit holder name (so a HashTable is probably a good implementation of the collection, with
 * permit holder name as key).
 *
 * There will only be one instance of this class.
 */
public class Permit_list {
    /** The Permit list maintains a collection of the Permits currently issued.
     *
     * This association must be implemented by an attribute holding a collection data structure (for
     * example: array, hash table - the latter is recommended).
     *
     * Note that no two Permits may have the same permit holder name (this information is not represented diagrammatically).
     * @associates Permit
     * @label Contains
     * @clientCardinality 1
     * @supplierCardinality 0..*
     * @directed*/
    private java.util.Hashtable<String, Permit> lnkPermit;
    
    public Permit_list(){
    	lnkPermit = new java.util.Hashtable<String, Permit>();
    }
    
    public void createRVP(String permitHolder, int lnkDate, int lnkDate1, String hostName) {
//    	Regular_visitor_permit rvp = new Regular_visitor_permit(permitHolder, lnkDate, lnkDate1, hostName);
//    	lnkPermit.put(permitHolder, rvp);
//    	addPermit(rvp);
    }
    
    public Permit getPermit(String permitHolder) {
    	return lnkPermit.get(permitHolder);
    }
    public void createUMP(String permitHolder, int lnkDate) {
//    	University_member_permit ump = new University_member_permit(permitHolder, lnkDate);
//    	lnkPermit.put(permitHolder, ump);
//    	addPermit(rvp);
    }
    
    public boolean checkNameExists(String permitHolder) {
    	return lnkPermit.containsKey(permitHolder);

    }
    
    public LinkedList<String> getKeys() {
    	LinkedList<String> keysList = new LinkedList<String>();
    	Enumeration<String> keys = lnkPermit.keys();
        while(keys.hasMoreElements()){
            String key = keys.nextElement();
            keysList.add(key);
            System.out.println("Permi List --- Value of key: "+key+" is: ");
//            +lnkPermit.get(key).toString()
    }
        return keysList;
    }
    
    public void removePermit(String permitHolder) {
    	lnkPermit.remove(permitHolder);
    }
    public int getSize() {
    	return lnkPermit.size();
    }
    public void addPermit(Permit p) {
    	Permit p2;
    	p2 = (Permit) lnkPermit.get(p.getName());
    	if (p2 == null)
    		lnkPermit.put(p.getName(), p);
    	else {
    		System.out.println("Permit List --- Collision occurring: two permits cannot share a common permit holder name ");
    		System.out.println("Existing permit name: " + p2.getName() + " New permit name: " + p.getName());
    	}	
    }
    
    public void dailyUpdateAll() {
    	Enumeration e = lnkPermit.elements();
    	while(e.hasMoreElements()) {
    		Permit p = (Permit) e.nextElement();
    		p.dailyReset();
    		}
    }
    
    public void annualUpdateAll() {
    	Enumeration e = lnkPermit.elements();
    	while(e.hasMoreElements()) {
    		Permit p = (Permit) e.nextElement();
    		p.unsuspend();
    		p.clearWarnings();
    		}
    }
}
