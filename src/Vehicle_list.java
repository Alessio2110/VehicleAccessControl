/* Generated by Together */

/**
 * Vehicle list manages the collection of vehicles currently associated with permits.
 * It handles checks of whether vehicles are allowed through the barriers, records warnings,
 * and various other functions. Note that each Vehicle_info object must have a unique registration
 * number, to allow sensible checking and recording of entries onto the campus (so a HashTable
 * is probably a good implementation of the collection, with registration number as key).
 *
 * There will only be one instance of this class.
 */
public class Vehicle_list {
    /** The Vehicle list maintains a collection of the known Vehicle_infos associated with all permits.
     * This association must be implemented by an attribute holding a collection data structure
     * (for example: array, hash table - the latter is recommended).
     *
     * Note that no two Vehicle_infos may have the same registration number (this information is
     * not represented diagrammatically) - this is to guarantee consistency with the constraint
     * that no vehicle is associated with more than one permit.
     *
     * Note that, given a registration number, the Vehicle_list can look up the appropriate Vehicle_info
     * instance, and via that it can obtain the vehicle's permit information.
     * @associates Vehicle_info
     * @label Contains
     * @clientCardinality 1
     * @supplierCardinality 0..*
     * @directed*/
//    private java.util.Hashtable lnkVehicle;
	private java.util.Hashtable<String, Vehicle_info> lnkVehicle;
	
    public Vehicle_list(){
    	lnkVehicle = new java.util.Hashtable<String, Vehicle_info>();
    }
//    Work in progress method
    public boolean isAllowed( String regNo) {
    	if (regNo.equals(""))
    		return false;
    	
    	boolean allowed = false;
    	Vehicle_info v = getVehicle(regNo);
    	
    	if (v != null) {
    		Permit p = v.getPermit();
    		allowed = p.isAllowed();
    		if (allowed)
    			updatePermit(p, v);
    	}
    	else
    		allowed = false;
    	return allowed;
    }
    
    public void updatePermit(Permit p, Vehicle_info v) {
    	p.increaseEntries();
    	p.setVehicle(v);
    }
    
    
    public void addVehicle(Vehicle_info v) {
    	Vehicle_info v2;
    	v2 = (Vehicle_info) lnkVehicle.get(v.getRegNo());
    	if (v2 == null)
    		lnkVehicle.put(v.getRegNo(), v);
    	else {
    		System.out.println("Collision occurring:");
    		System.out.println("New vehicle:" + v.getRegNo() + " " + v.getPermit() + " Registered Vehicle: " + v2.getRegNo() + " " + v2.getPermit());
    	}	
    }
    
    public void addSimpleVehicle(String regNo){
    	Vehicle_info v = new Vehicle_info(regNo);
    	lnkVehicle.put(v.getRegNo(), v);
    }
    
    public void addPermitVehicle(Vehicle_info v) {
//    	Vehicle_info v2;
//    	v2 = (Vehicle_info) lnkVehicle.get(v.getRegNo());
//    	if (v2 == null)
//    		lnkVehicle.put(v.getRegNo(), v);
//    	else {
//    		System.out.println("Collision occurring:");
//    		System.out.println("New vehicle:" + v.getRegNo() + " " + v.getPermit() + " Registered Vehicle: " + v2.getRegNo() + " " + v2.getPermit());
//    	}	
    }
//    Find vehicle info given the registration number
    public Vehicle_info getVehicle(String regNo) {
    	Vehicle_info v;
    	v = (Vehicle_info) lnkVehicle.get(regNo);
    	return v;
    }
    
    public int getSize() {
    	return lnkVehicle.size();
    }
//    public int hashCode() {
//    	return 1;
//    }
//    
//    public Object get(Object key) {
//    	return key;
//    }
//    
//    public boolean equals() {
//    	return true;
//    }
}
